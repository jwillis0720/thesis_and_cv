\section{Appendix V - Computational Standard Operating Procedures}
\label{sec:appenixV}
Here I will detail the computational procedures including running \rosetta and analyzing data with scripts that are often available in the Meiler Lab Scripts repository or available on request. Also a lot of the procedures are detailed in IPython Notebooks and will also be available on request.
\subsection{Chapter I - Multi-State Design}
Here I will detail how I ran \rosettadesign for multi-state design and how I analyzed the results. I will use the simplified example of IGH\textsubscript{V}5-51 which only contains three sets of molecular structures. There is a great protocol capture for complex procedures attached to the publication by Andrew Leaver-Fay showing how to \textit{design for} and \textit{design against} in multiple states \citep{LeaverFay:2011ji}.
\subsubsection{Running Rosetta Multi-State Design}
To run multi-state design, I have to prepare several files.

\begin{itemize}
\item Entity File - A file containing the amount of residue positions to design as well as instructions for the packer to behave on all proteins. For example, we could want the packer only to use certain rotamers around the interface. This could be handled with the entity file.
\item Correlation File - Tells how residues correlate to each other. For example, residue 1 on protein A should be designed with residue 2 on protein B etc.
\item Secondary Residue File - This is a residue file as defined in the documentation, but will only instruct the packer to operate on each protein individually. Every state must have it's own secondary residue file.
\item Fitness File - A master file containing all other files as well as instructions for the fitness function.
\end{itemize}

\textbf{Clean PDB} - First, I can download all three protein PDBs with the clean\_pdb.py script. Clean PDB supports the following syntax:

\begin{verbatim}
clean_pdb.py <PDB_ID> <CHAINS>
\end{verbatim}

We only want the asymmetric unit in the crystal structure, so it helps to manually inspect the PDBs. We need one heavy chain, one light chain, and one antigen. I just go to www.pdb.org to find these chain codes.
\begin{verbatim}
clean_pdb.py 2B1A HLP
clean_pdb.py 2XWT ABC
clean_pdb.py 3HMX HLB
\end{verbatim}
Although not absolutely necessary, it makes it easier to label the chain IDs the same. All heavy chains have H, light L, and antigen A. There is a change PDB id script which allows us to quickly rename chain IDs. The script takes the following syntax.

\begin{verbatim}
set_pdb_chain_id.py old_chain new_chain input output
\end{verbatim}
I have looked through all the PDBs and figured out which names to change.

\begin{verbatim}
set_pdb_chain_id.py P A 2B1A_HLP.pdb 2B1A_HLA.pdb
set_pdb_chain_id.py A H 2XWT_ABC.pdb 2XWT_HBC.pdb
set_pdb_chain_id.py B L 2XWT_HBC.pdb 2XWT_HLC.pdb
set_pdb_chain_id.py C L 2XWT_HLC.pdb 2XWT_HLA.pdb
set_pdb_chain_id.py C A 2XWT_HLC.pdb 2XWT_HLA.pdb
set_pdb_chain_id.py B A 3HMX_HLB.pdb 3HMX_HLA.pdb
\end{verbatim}
For good measure some of the PDBs don't start numbering scheme correctly so to make it easier we should renumber each chain starting with 1.

\begin{verbatim}
renumber_pdb.py 2B1A_HLA.pdb 2B1A_clean.pdb
renumber_pdb.py 2XWT_HLA.pdb 2XWT_clean.pdb
renumber_pdb.py 3HMX_HLA.pdb 3HMX_clean.pdb
\end{verbatim}
Now we can remove all temporary files, only *\_clean.pdb files should remain in the working directory. The next thing to do would be to find all positions with at least one difference. This requires manual inspection of the alignment. For the V\textsubscript{H} gene, there are 29 amino acid positions that will differ from germline in at least one position. These positions will be considered. Given that data, we can construct the entity residue file.

\begin{verbatim}
#The entity.resfile
29 #The number of positions to design
ALLAAxc EX 1 EX 2 EX ARO 2 #Allow all amino acids
#except cystine and use rotamer libraries 1,2
#and aromatic 2.
start #beginning of residue file.
\end{verbatim}

The correlation file maps how each residue in each file should map to the others. There will be three correlation files, one for each state. Since each amino acid lines up, i.e. design position 5 in 2B1A with position 5 in 3HMX, all the correlation files will be the same. Here is an example of one correlation file.

\begin{verbatim}
#all.corr
#The first column is the entity,
#the second is the residue number for that state,
#the last is the chain.
1 5 H
2 14 H
3 16 H
4 23 H
5 24 H
6 29 H
7 30 H
8 31 H
9 32 H
10 34 H
11 40 H
12 46 H
13 48 H
14 51 H
15 52 H
16 54 H
17 58 H
18 65 H
19 70 H
20 72 H
21 74 H
22 76 H
23 77 H
24 80 H
25 84 H
26 88 H
27 93 H
28 97 H
29 98 H
\end{verbatim}
A secondary residue file is also needed in case any extra packing tasks are needed to be supplied to each state. For example, we could tell one PDB state to design around the interface in single state design mode while everything in the correlation file designs together. I do not require extra design tasks for this protocol so all secondary residue files will be the same. For example,

\begin{verbatim}
NATRO #tells the packer to use all natural side
#chain configurations for everything
#that is not being designed.
use_input_sc #the input side chain is allowed
start #start the residue file
\end{verbatim}

We next to create a states file that has the PDB, correlation file and secondary resfile names in it. Name them 2B1A.states, 2XWT.states, and 3HMX.states. They should look like the following when opened.

\begin{verbatim}
#2B1A.states
2B1A_clean.pdb all.corr all.2res

#2XWT.states
2XWT_clean.pdb all.corr all.2res

#3HMX.states
3HMX_clean.pdb all.corr all.2res
\end{verbatim}

Lastly, a fitness file needs to be constructed to tell multi-state how to design. I call this file fitness.daf and it points to the locations of the states files.

\begin{verbatim}
#initialize the states and what the states file name is
STATE_VECTOR A 2b1a.states
STATE_VECTOR B 2xwt.states
STATE_VECTOR C 3hmx.states


#tell design to minimize energy for each state
SCALAR_EXPRESSION best_A = vmin( A )
SCALAR_EXPRESSION best_B = vmin( B )
SCALAR_EXPRESSION best_C = vmin( C )

#Fitness - design to minimize all energies simultaneously
FITNESS best_A + best_B + best_C
\end{verbatim}

\textbf{Running Rosetta Multi-State Design} \\
The \rosetta executable is called mpi\_msd.mpi.<operatingsystem>. It must be compiled in MPI mode as each state is assigned to a processor. The command line takes the following options.

\begin{itemize}
\item entity\_resfile - The resfile that we created in the input portion
\item fitness\_file - The fitness file we created in the input portion
\item ms::pop\_size - How many sequences to keep in memory at once (100 is a good number)
\item ms::generation - How many sequence generations should MSD go through see \citep{LeaverFay:2011ji} to find see how the genetic algorithm selects sequences.
\item ms::numresults - How many results to output. Will output top N sequences.
\item ms:fraction\_by\_recombination - How often should a cross-over even take place between sequences in the population. Read \citep{LeaverFay:2011ji} for details on the genetic algorithm.
\item database - The location of the database.
\end{itemize}

I construct an options file with all those options (options.txt) that looks like this.

\begin{verbatim}
-entity_resfile entity.resfile
-fitness_file fitness.daf
-ms
    -pop_size 100
    -generations 435
    -numresults 100
    -fraction_by_recombination .04
-database my/rosetta/database/location/
\end{verbatim}

Finally we can run \rosetta using the following command.

\begin{verbatim}
mpiexec -n 4 /my/rosetta/location/mpi_msd.mpi.myoperatingsystem \
@options.txt
\end{verbatim}
\textbf{Warning! \linebreak \rosetta may complain about some of the comments (anything starting with \#) not being recognized, if so, just remove it from the file}
